"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useFixtures = exports.expect = exports.afterAll = exports.afterEach = exports.beforeEach = exports.beforeAll = exports.describe = exports.test = exports.it = exports.fixtures = void 0;
exports.useBase = useBase;
const test_1 = require("@playwright/test");
const core_1 = require("@serenity-js/core");
const events_1 = require("@serenity-js/core/lib/events");
const model_1 = require("@serenity-js/core/lib/model");
const playwright_1 = require("@serenity-js/playwright");
const rest_1 = require("@serenity-js/rest");
const web_1 = require("@serenity-js/web");
const os = __importStar(require("os"));
const tiny_types_1 = require("tiny-types");
const reporter_1 = require("../reporter");
const PerformActivitiesAsPlaywrightSteps_1 = require("./PerformActivitiesAsPlaywrightSteps");
const serenitySelectorEngines = new playwright_1.SerenitySelectorEngines();
exports.fixtures = {
    actors: [
        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
        async ({ contextOptions, baseURL, extraHTTPHeaders, page, proxy }, use) => {
            await use(core_1.Cast.where(actor => actor.whoCan(playwright_1.BrowseTheWebWithPlaywright.usingPage(page, contextOptions), core_1.TakeNotes.usingAnEmptyNotepad(), rest_1.CallAnApi.using({
                baseURL: baseURL,
                headers: extraHTTPHeaders,
                proxy: proxy && proxy?.server
                    ? asProxyConfig(proxy)
                    : undefined,
            }))));
        },
        { option: true },
    ],
    playwright: async ({ playwright }, use) => {
        await serenitySelectorEngines.ensureRegisteredWith(playwright.selectors);
        await use(playwright);
    },
    defaultActorName: [
        'Serena',
        { option: true },
    ],
    cueTimeout: [
        core_1.Duration.ofSeconds(5),
        { option: true },
    ],
    interactionTimeout: [
        core_1.Duration.ofSeconds(5),
        { option: true },
    ],
    crew: [
        [
            web_1.Photographer.whoWill(web_1.TakePhotosOfFailures)
        ],
        { option: true },
    ],
    // eslint-disable-next-line no-empty-pattern
    platform: async ({}, use) => {
        const platform = os.platform();
        // https://nodejs.org/api/process.html#process_process_platform
        const name = platform === 'win32'
            ? 'Windows'
            : (platform === 'darwin' ? 'macOS' : 'Linux');
        await use({ name, version: os.release() });
    },
    serenity: async ({ crew, cueTimeout, interactionTimeout, platform }, use, info) => {
        const domainEventBuffer = new reporter_1.DomainEventBuffer();
        core_1.serenity.configure({
            diffFormatter: new core_1.AnsiDiffFormatter(),
            cueTimeout: asDuration(cueTimeout),
            interactionTimeout: asDuration(interactionTimeout),
            crew: [
                ...crew,
                domainEventBuffer,
                new reporter_1.PlaywrightStepReporter(info),
            ],
        });
        core_1.serenity.announce(new events_1.SceneTagged(core_1.serenity.currentSceneId(), new model_1.PlatformTag(platform.name, platform.version), core_1.serenity.currentTime()));
        await use(core_1.serenity);
        const serialisedEvents = [];
        for (const event of domainEventBuffer.flush()) {
            serialisedEvents.push({
                type: event.constructor.name,
                value: event.toJSON(),
            });
            if (event instanceof events_1.SceneTagged) {
                exports.test.info().annotations.push({ type: event.tag.type, description: event.tag.name });
            }
        }
        info.attach('serenity-js-events.json', {
            contentType: reporter_1.SERENITY_JS_DOMAIN_EVENTS_ATTACHMENT_CONTENT_TYPE,
            body: Buffer.from(JSON.stringify(serialisedEvents), 'utf8'),
        });
    },
    actorCalled: async ({ serenity, actors, browser, browserName, contextOptions }, use) => {
        const sceneId = serenity.currentSceneId();
        serenity.engage(asCast(actors));
        const actorCalled = (name) => {
            const actor = serenity.theActorCalled(name);
            return actor.whoCan(new PerformActivitiesAsPlaywrightSteps_1.PerformActivitiesAsPlaywrightSteps(actor, serenity, exports.it));
        };
        serenity.announce(new events_1.SceneTagged(sceneId, new model_1.BrowserTag(browserName, browser.version()), serenity.currentTime()));
        await use(actorCalled);
        serenity.announce(new events_1.SceneFinishes(sceneId, serenity.currentTime()));
        await core_1.serenity.waitForNextCue();
    },
    actor: async ({ actorCalled, defaultActorName }, use) => {
        await use(actorCalled(defaultActorName));
    },
};
function createTestApi(baseTest) {
    return {
        useFixtures(customFixtures) {
            return createTestApi(baseTest.extend(customFixtures));
        },
        beforeAll: baseTest.beforeAll,
        beforeEach: baseTest.beforeEach,
        afterEach: baseTest.afterEach,
        afterAll: baseTest.afterAll,
        describe: baseTest.describe,
        expect: baseTest.expect,
        it: baseTest,
        test: baseTest,
    };
}
const api = createTestApi(test_1.test).useFixtures(exports.fixtures);
/**
 * Declares a single test scenario.
 *
 * ## Example
 *
 * ```typescript
 * import { Ensure, equals } from '@serenity-js/assertions'
 * import { describe, it } from '@serenity-js/playwright-test'
 *
 * describe(`Todo List App`, () => {
 *
 *   it(`should allow me to add a todo item`, async ({ actor }) => {
 *     await actor.attemptsTo(
 *       startWithAnEmptyList(),
 *
 *       recordItem('Buy some milk'),
 *
 *       Ensure.that(itemNames(), equals([
 *         'Buy some milk',
 *       ])),
 *     )
 *   })
 *
 *   it('supports multiple actors using separate browsers', async ({ actorCalled }) => {
 *     await actorCalled('Alice').attemptsTo(
 *       startWithAListContaining(
 *         'Feed the cat'
 *       ),
 *     )
 *
 *     await actorCalled('Bob').attemptsTo(
 *       startWithAListContaining(
 *         'Walk the dog'
 *       ),
 *     )
 *
 *     await actorCalled('Alice').attemptsTo(
 *       Ensure.that(itemNames(), equals([
 *         'Feed the cat'
 *       ])),
 *     )
 *
 *     await actorCalled('Bob').attemptsTo(
 *       Ensure.that(itemNames(), equals([
 *         'Walk the dog'
 *       ])),
 *     )
 *   })
 * })
 * ```
 *
 * ## Learn more
 * - [Grouping test scenarios](https://serenity-js.org/api/playwright-test/function/describe/)
 * - [`SerenityFixtures`](https://serenity-js.org/api/playwright-test/interface/SerenityFixtures/)
 * - [Playwright Test `test` function](https://playwright.dev/docs/api/class-test#test-call)
 * - [Serenity/JS + Playwright Test project template](https://github.com/serenity-js/serenity-js-playwright-test-template/)
 */
exports.it = api.it;
/**
 * Declares a single test scenario. Alias for [`it`](https://serenity-js.org/api/playwright-test/function/it/).
 */
exports.test = api.test;
/**
 * Declares a group of test scenarios.
 *
 * ## Example
 *
 * ```typescript
 * import { Ensure, equals } from '@serenity-js/assertions'
 * import { describe, it, test } from '@serenity-js/playwright-test'
 * import { Photographer, TakePhotosOfFailures, Value } from '@serenity-js/web'
 *
 * describe(`Todo List App`, () => {
 *
 *   test.use({
 *     defaultActorName: 'Serena',
 *     crew: [
 *       Photographer.whoWill(TakePhotosOfFailures),
 *     ],
 *   })
 *
 *   it(`should allow me to add a todo item`, async ({ actor }) => {
 *     await actor.attemptsTo(
 *       startWithAnEmptyList(),
 *
 *       recordItem('Buy some milk'),
 *
 *       Ensure.that(itemNames(), equals([
 *         'Buy some milk',
 *       ])),
 *     )
 *   })
 *
 *   it('should clear text input field when an item is added', async ({ actor }) => {
 *     await actor.attemptsTo(
 *       startWithAnEmptyList(),
 *
 *       recordItem('Buy some milk'),
 *
 *       Ensure.that(Value.of(newTodoInput()), equals('')),
 *     )
 *   })
 * })
 * ```
 *
 * ## Learn more
 * - Declaring a Serenity/JS [test scenario](https://serenity-js.org/api/playwright-test/function/it/)
 * - [Playwright Test `describe` function](https://playwright.dev/docs/api/class-test#test-describe-1)
 * - [Serenity/JS + Playwright Test project template](https://github.com/serenity-js/serenity-js-playwright-test-template/)
 */
exports.describe = api.describe;
exports.beforeAll = api.beforeAll;
exports.beforeEach = api.beforeEach;
exports.afterEach = api.afterEach;
exports.afterAll = api.afterAll;
exports.expect = api.expect;
exports.useFixtures = api.useFixtures;
/**
 * Creates a Serenity/JS BDD-style test API around the given Playwright [base test](https://playwright.dev/docs/test-fixtures).
 *
 * ## Using default configuration
 *
 * When your test scenario doesn't require [custom test fixtures](https://playwright.dev/docs/test-fixtures),
 * and you're happy with the default [base test](https://playwright.dev/docs/api/class-test#test-call) offered by Playwright,
 * you can import test API functions such as [`describe`](https://serenity-js.org/api/playwright-test/function/describe/) and [`it`](https://serenity-js.org/api/playwright-test/function/describe/) directly from `@serenity-js/playwright-test`.
 *
 * ```typescript
 * import { describe, it, test } from '@serenity-js/playwright-test'
 * import { Log } from '@serenity-js/core'
 *
 * // override default fixtures if needed
 * test.use({
 *   defaultActorName: 'Alice'
 * })
 *
 * describe('Serenity/JS default test API', () => {
 *
 *   it('enables easy access to actors and standard Playwright fixtures', async ({ actor, browserName }) => {
 *     await actor.attemptsTo(
 *       Log.the(browserName),
 *     )
 *   })
 * })
 * ```
 *
 * In the above example, importing test API functions directly from `@serenity-js/playwright-test` is the equivalent of the following setup:
 *
 * ```typescript
 * import { test as playwrightBaseTest } from '@playwright/test'
 * import { useBase } from '@serenity-js/playwright-test'
 *
 * const { describe, it, test, beforeEach, afterEach } = useBase(playwrightBaseTest)
 * ```
 *
 * ## Using custom fixtures
 *
 * When your test scenario requires [custom test fixtures](https://playwright.dev/docs/test-fixtures),
 * but you're still happy with the default [base test](https://playwright.dev/docs/api/class-test#test-call) offered by Playwright,
 * you can create fixture-aware test API functions such as [`describe`](https://serenity-js.org/api/playwright-test/function/describe/) and [`it`](https://serenity-js.org/api/playwright-test/function/describe/)
 * by calling [`useFixtures`](https://serenity-js.org/api/playwright-test/function/useFixtures/).
 *
 * For example, you can create a test scenario using a static `message` fixture as follows:
 *
 * ```typescript
 * import { useFixtures } from '@serenity-js/playwright-test'
 * import { Log } from '@serenity-js/core'
 *
 * const { describe, it } = useFixtures<{ message: string }>({
 *   message: 'Hello world!'
 * })
 *
 * describe('Serenity/JS useFixtures', () => {
 *
 *   it('enables injecting custom test fixtures into test scenarios', async ({ actor, message }) => {
 *     await actor.attemptsTo(
 *       Log.the(message),
 *     )
 *   })
 * })
 * ```
 *
 * The value of your test fixtures can be either static or dynamic and based on the value of other fixtures.
 *
 * To create a dynamic test fixture use the [function syntax](https://playwright.dev/docs/test-fixtures):
 *
 * ```typescript
 * import { Log } from '@serenity-js/core'
 * import { useFixtures } from '@serenity-js/playwright-test'
 *
 * const { describe, it } = useFixtures<{ message: string }>({
 *   message: async ({ actor }, use) => {
 *     await use(`Hello, ${ actor.name }`);
 *   }
 * })
 *
 * describe('Serenity/JS useFixtures', () => {
 *
 *   it('enables injecting custom test fixtures into test scenarios', async ({ actor, message }) => {
 *     await actor.attemptsTo(
 *       Log.the(message),
 *     )
 *   })
 * })
 * ```
 *
 * In the above example, creating test API functions via `useFixtures` is the equivalent of the following setup:
 *
 * ```typescript
 * import { test as playwrightBaseTest } from '@playwright/test'
 * import { useBase } from '@serenity-js/playwright-test'
 *
 * const { describe, it, test, beforeEach, afterEach } = useBase(playwrightBaseTest)
 *   .useFixtures<{ message: string }>({
 *     message: async ({ actor }, use) => {
 *       await use(`Hello, ${ actor.name }`);
 *     }
 *   })
 * ```
 *
 * ## Using custom base test
 *
 * In cases where you need to use a non-default base test, for example when doing [UI component testing](https://playwright.dev/docs/test-components),
 * you can create Serenity/JS test API functions around your preferred base test.
 *
 * ```tsx
 * import { test as componentTest } from '@playwright/experimental-ct-react'
 * import { Ensure, contain } from '@serenity-js/assertions'
 * import { useBase } from '@serenity-js/playwright-test'
 * import { Enter, PageElement, CssClasses } from '@serenity-js/web'
 *
 * import EmailInput from './EmailInput';
 *
 * const { it, describe } = useBase(componentTest).useFixtures<{ emailAddress: string }>({
 *   emailAddress: ({ actor }, use) => {
 *     use(`${ actor.name }@example.org`)
 *   }
 * })
 *
 * describe('EmailInput', () => {
 *
 *   it('allows valid email addresses', async ({ actor, mount, emailAddress }) => {
 *     const nativeComponent = await mount(<EmailInput/>);
 *
 *     const component = PageElement.from(nativeComponent);
 *
 *     await actor.attemptsTo(
 *       Enter.theValue(emailAddress).into(component),
 *       Ensure.that(CssClasses.of(component), contain('valid')),
 *     )
 *   })
 * })
 * ```
 *
 * @param baseTest
 */
function useBase(baseTest) {
    return createTestApi(baseTest)
        .useFixtures(exports.fixtures);
}
/**
 * @private
 * @param maybeDuration
 */
function asDuration(maybeDuration) {
    return maybeDuration instanceof core_1.Duration
        ? maybeDuration
        : core_1.Duration.ofMilliseconds(maybeDuration);
}
/**
 * @private
 * @param maybeCast
 */
function asCast(maybeCast) {
    return (0, tiny_types_1.ensure)('actors', maybeCast, (0, tiny_types_1.property)('prepare', (0, tiny_types_1.isFunction)()));
}
/**
 * @private
 * @param proxy
 */
function asProxyConfig(proxy) {
    // Playwright defaults to http when proxy.server does not define the protocol
    // See https://playwright.dev/docs/api/class-testoptions#test-options-proxy
    const hasProtocol = /[\dA-Za-z]+:\/\//.test(proxy.server);
    const proxyUrl = hasProtocol
        ? new URL(proxy.server)
        : new URL(`http://${proxy.server}`);
    const host = proxyUrl.hostname;
    const port = proxyUrl.port
        ? Number(proxyUrl.port)
        : undefined;
    const auth = proxy.username
        ? { username: proxy.username, password: proxy.password || '' }
        : undefined;
    return {
        protocol: proxyUrl.protocol,
        host,
        port,
        auth
    };
}
//# sourceMappingURL=test-api.js.map