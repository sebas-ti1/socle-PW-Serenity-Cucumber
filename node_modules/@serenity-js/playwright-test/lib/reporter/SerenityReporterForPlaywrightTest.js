"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SerenityReporterForPlaywrightTest = void 0;
const core_1 = require("@serenity-js/core");
const events = __importStar(require("@serenity-js/core/lib/events"));
const events_1 = require("@serenity-js/core/lib/events");
const io_1 = require("@serenity-js/core/lib/io");
const model_1 = require("@serenity-js/core/lib/model");
const PlaywrightAttachments_1 = require("./PlaywrightAttachments");
/**
 * Serenity/JS reporter that receives notifications from Playwright Test and emits them as
 * Serenity/JS [Serenity/JS domain events](https://serenity-js.org/api/core-events/class/DomainEvent/) which can be used by
 * Serenity/JS [stage crew members](https://serenity-js.org/api/core/interface/StageCrewMember/).
 */
class SerenityReporterForPlaywrightTest {
    serenity;
    requirementsHierarchy;
    errorParser = new PlaywrightErrorParser();
    sceneIds = new Map();
    unhandledError;
    /**
     * @param config
     * @param serenity
     *  Instance of [`Serenity`](https://serenity-js.org/api/core/class/Serenity/), specific to the Node process running this Serenity reporter.
     *  Note that Playwright runs test workers and reporters in separate processes.
     * @param requirementsHierarchy
     *  Root directory of the requirements hierarchy, used to determine capabilities and themes.
     */
    constructor(config, serenity = core_1.serenity, requirementsHierarchy = new io_1.RequirementsHierarchy(new io_1.FileSystem(io_1.Path.from(process.cwd())))) {
        this.serenity = serenity;
        this.requirementsHierarchy = requirementsHierarchy;
        this.serenity.configure(config);
    }
    onBegin(config, suite) {
        this.requirementsHierarchy = new io_1.RequirementsHierarchy(new io_1.FileSystem(io_1.Path.from(config.rootDir)));
        this.serenity.announce(new events_1.TestRunStarts(this.now()));
    }
    onTestBegin(test) {
        const currentSceneId = this.serenity.assignNewSceneId();
        this.sceneIds.set(test.id, currentSceneId);
        const { scenarioDetails, scenarioTags } = this.scenarioDetailsFrom(test);
        const tags = [
            ...scenarioTags,
            ...test.tags.flatMap(tag => model_1.Tags.from(tag)),
        ];
        this.emit(new events_1.SceneStarts(currentSceneId, scenarioDetails, this.serenity.currentTime()), ...this.requirementsHierarchy
            .requirementTagsFor(scenarioDetails.location.path, scenarioDetails.category.value)
            .map(tag => new events_1.SceneTagged(currentSceneId, tag, this.serenity.currentTime())), new events_1.TestRunnerDetected(currentSceneId, new model_1.Name('Playwright'), this.serenity.currentTime()), ...tags.map(tag => new events_1.SceneTagged(currentSceneId, tag, this.serenity.currentTime())));
    }
    // TODO might be nice to support that by emitting TestStepStarted / Finished
    // onStepBegin(test: TestCase, _result: TestResult, step: TestStep): void {
    //     // console.log('>> onStepBegin');
    // }
    // onStepEnd(test: TestCase, _result: TestResult, step: TestStep): void {
    //     // console.log('>> onStepEnd');
    // }
    onTestEnd(test, result) {
        this.announceRetryIfNeeded(test, result);
        const currentSceneId = this.sceneIds.get(test.id);
        let worstInteractionOutcome = new model_1.ExecutionSuccessful();
        for (const attachment of result.attachments) {
            if (!(attachment.contentType === PlaywrightAttachments_1.SERENITY_JS_DOMAIN_EVENTS_ATTACHMENT_CONTENT_TYPE && attachment.body)) {
                continue;
            }
            const messages = JSON.parse(attachment.body.toString());
            for (const message of messages) {
                if (message.value.sceneId === 'unknown') {
                    message.value.sceneId = currentSceneId.value;
                }
                const event = events[message.type].fromJSON(message.value);
                this.serenity.announce(event);
                if (event instanceof events_1.InteractionFinished && event.outcome.isWorseThan(worstInteractionOutcome)) {
                    worstInteractionOutcome = event.outcome;
                }
            }
        }
        const scenarioOutcome = this.outcomeFrom(test, result);
        this.serenity.announce(new events_1.SceneFinished(currentSceneId, this.scenarioDetailsFrom(test).scenarioDetails, this.determineScenarioOutcome(worstInteractionOutcome, scenarioOutcome), this.now()));
    }
    onError(error) {
        if (!this.unhandledError) {
            this.unhandledError = this.errorParser.errorFrom(error);
        }
    }
    determineScenarioOutcome(worstInteractionOutcome, scenarioOutcome) {
        if (worstInteractionOutcome instanceof model_1.ExecutionFailedWithAssertionError) {
            return worstInteractionOutcome;
        }
        return worstInteractionOutcome.isWorseThan(scenarioOutcome)
            ? worstInteractionOutcome
            : scenarioOutcome;
    }
    outcomeFrom(test, result) {
        const outcome = test.outcome();
        if (outcome === 'skipped') {
            return new model_1.ExecutionSkipped();
        }
        if (outcome === 'unexpected' && result.status === 'passed') {
            return new model_1.ExecutionFailedWithError(new core_1.LogicError(`Scenario expected to fail, but ${result.status}`));
        }
        if (['failed', 'interrupted', 'timedOut'].includes(result.status)) {
            if (test.retries > result.retry) {
                return new model_1.ExecutionIgnored(this.errorParser.errorFrom(result.error));
            }
            return new model_1.ExecutionFailedWithError(this.errorParser.errorFrom(result.error));
        }
        return new model_1.ExecutionSuccessful();
    }
    scenarioDetailsFrom(test) {
        const [root_, browserName_, fileName, describeOrItBlockTitle, ...nestedTitles] = test.titlePath();
        const path = new io_1.Path(test.location.file);
        const scenarioName = nestedTitles.join(' ').trim();
        const name = scenarioName || describeOrItBlockTitle;
        const featureName = scenarioName ? describeOrItBlockTitle : fileName;
        return {
            scenarioDetails: new model_1.ScenarioDetails(new model_1.Name(model_1.Tags.stripFrom(name)), new model_1.Category(model_1.Tags.stripFrom(featureName)), new io_1.FileSystemLocation(path, test.location.line, test.location.column)),
            scenarioTags: model_1.Tags.from(`${featureName} ${name}`),
        };
    }
    async onEnd() {
        this.serenity.announce(new events_1.TestRunFinishes(this.serenity.currentTime()));
        try {
            await this.serenity.waitForNextCue();
            const outcome = this.unhandledError ?
                new model_1.ExecutionFailedWithError(this.unhandledError)
                : new model_1.ExecutionSuccessful();
            this.serenity.announce(new events_1.TestRunFinished(outcome, this.serenity.currentTime()));
        }
        catch (error) {
            this.serenity.announce(new events_1.TestRunFinished(new model_1.ExecutionFailedWithError(error), this.serenity.currentTime()));
            throw error;
        }
    }
    // TODO emit a text artifact with stdout?
    // reporter.onStdErr(chunk, test, result)
    // reporter.onStdOut(chunk, test, result)
    emit(...events) {
        events.forEach((event) => {
            this.serenity.announce(event);
        });
    }
    announceRetryIfNeeded(test, result) {
        if (test.retries === 0) {
            return;
        }
        const currentSceneId = this.sceneIds.get(test.id);
        this.emit(new events_1.RetryableSceneDetected(currentSceneId, this.now()), new events_1.SceneTagged(currentSceneId, new model_1.ArbitraryTag('retried'), // todo: replace with a dedicated tag
        this.now()));
        if (result.retry > 0) {
            this.emit(new events_1.SceneTagged(currentSceneId, new model_1.ExecutionRetriedTag(result.retry), this.serenity.currentTime()));
        }
    }
    now() {
        return this.serenity.currentTime();
    }
    printsToStdio() {
        return true;
    }
}
exports.SerenityReporterForPlaywrightTest = SerenityReporterForPlaywrightTest;
class PlaywrightErrorParser {
    static ascii = new RegExp('[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))', // eslint-disable-line no-control-regex
    'g');
    errorFrom(testError) {
        const message = testError.message && PlaywrightErrorParser.stripAsciiFrom(testError.message);
        let stack = testError.stack && PlaywrightErrorParser.stripAsciiFrom(testError.stack);
        // TODO: Do I need to process it?
        // const value     = testError.value;
        const prologue = `Error: ${message}`;
        if (stack && message && stack.startsWith(prologue)) {
            stack = stack.slice(prologue.length);
        }
        const error = new Error(message);
        error.stack = stack;
        return error;
    }
    static stripAsciiFrom(text) {
        return text.replace(this.ascii, '');
    }
}
//# sourceMappingURL=SerenityReporterForPlaywrightTest.js.map