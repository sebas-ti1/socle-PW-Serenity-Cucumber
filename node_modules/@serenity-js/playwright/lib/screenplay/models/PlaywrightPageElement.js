"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlaywrightPageElement = void 0;
const core_1 = require("@serenity-js/core");
const web_1 = require("@serenity-js/web");
const scripts = __importStar(require("@serenity-js/web/lib/scripts"));
const tiny_types_1 = require("tiny-types");
/**
 * Playwright-specific implementation of [`PageElement`](https://serenity-js.org/api/web/class/PageElement/).
 *
 * @group Models
 */
class PlaywrightPageElement extends web_1.PageElement {
    of(parent) {
        return new PlaywrightPageElement(this.locator.of(parent.locator));
    }
    closestTo(child) {
        return new PlaywrightPageElement(this.locator.closestTo(child.locator));
    }
    async enterValue(value) {
        const text = [].concat(value).join('');
        const element = await this.nativeElement();
        return element.fill(text);
    }
    async clearValue() {
        try {
            const element = await this.nativeElement();
            await element.fill('');
        }
        catch (error) {
            throw new core_1.LogicError(`The input field doesn't seem to have a 'value' attribute that could be cleared`, error);
        }
    }
    async click() {
        const element = await this.nativeElement();
        return element.click();
    }
    async doubleClick() {
        const element = await this.nativeElement();
        return element.dblclick();
    }
    async scrollIntoView() {
        const element = await this.nativeElement();
        return element.scrollIntoViewIfNeeded();
    }
    async hoverOver() {
        const element = await this.nativeElement();
        return element.hover();
    }
    async rightClick() {
        const element = await this.nativeElement();
        return element.click({ button: 'right' });
    }
    async selectOptions(...options) {
        const element = await this.nativeElement();
        const optionsToSelect = options.map(option => ({
            value: option.value,
            label: option.label,
        }));
        await element.selectOption(optionsToSelect);
    }
    async selectedOptions() {
        const element = await this.nativeElement();
        /* c8 ignore start */
        const options = await element.locator('option').evaluateAll((optionNodes) => optionNodes.map((optionNode) => {
            return {
                selected: optionNode.selected,
                disabled: optionNode.disabled,
                label: optionNode.label,
                value: optionNode.value,
            };
        }));
        /* c8 ignore stop */
        return options.map(option => new web_1.SelectOption(option.label, option.value, option.selected, option.disabled));
    }
    async attribute(name) {
        const element = await this.nativeElement();
        return element.getAttribute(name);
    }
    async text() {
        const element = await this.nativeElement();
        return element.innerText(); // eslint-disable-line unicorn/prefer-dom-node-text-content
    }
    async value() {
        const element = await this.nativeElement();
        return element.inputValue();
    }
    async html() {
        const element = await this.nativeElement();
        return element.evaluate(nativeElement => nativeElement.outerHTML);
    }
    async switchTo() {
        try {
            const nativeLocator = await this.nativeElement();
            const element = await nativeLocator.elementHandle();
            const frame = await element.contentFrame();
            if (frame) {
                const locator = this.locator;
                await locator.switchToFrame(nativeLocator);
                return {
                    switchBack: async () => {
                        await locator.switchToParentFrame();
                    }
                };
            }
            /* c8 ignore start */
            const previouslyFocusedElement = await nativeLocator.evaluateHandle((domNode) => {
                const currentlyFocusedElement = document.activeElement;
                domNode.focus();
                return currentlyFocusedElement;
            });
            /* c8 ignore stop */
            return new PreviouslyFocusedElementSwitcher(previouslyFocusedElement);
        }
        catch (error) {
            throw new core_1.LogicError(`Couldn't switch to page element located ${this.locator}`, error);
        }
    }
    async isActive() {
        try {
            const element = await this.nativeElement();
            return element.evaluate(domNode => domNode === document.activeElement);
        }
        catch {
            return false;
        }
    }
    async isClickable() {
        try {
            const element = await this.nativeElement();
            await element.click({ trial: true });
            return true;
        }
        catch {
            return false;
        }
    }
    async isEnabled() {
        try {
            const element = await this.nativeElement();
            return element.isEnabled();
        }
        catch {
            return false;
        }
    }
    async isSelected() {
        try {
            const element = await this.nativeElement();
            // works for <option />
            const selected = await element.getAttribute('selected');
            if (selected !== null) {
                return true;
            }
            // works only for checkboxes and radio buttons, throws for other elements
            return await element.isChecked();
        }
        catch {
            return false;
        }
    }
    async isVisible() {
        try {
            const element = await this.nativeElement();
            const isVisible = await element.isVisible();
            if (!isVisible) {
                return false;
            }
            return await element.evaluate(scripts.isVisible);
        }
        catch {
            return false;
        }
    }
}
exports.PlaywrightPageElement = PlaywrightPageElement;
/**
 * @private
 */
class PreviouslyFocusedElementSwitcher {
    node;
    constructor(node) {
        this.node = node;
        (0, tiny_types_1.ensure)('DOM element', node, (0, tiny_types_1.isDefined)());
    }
    async switchBack() {
        /* c8 ignore start */
        await this.node.evaluate((domNode) => {
            domNode.focus();
        }, this.node);
        /* c8 ignore stop */
    }
}
//# sourceMappingURL=PlaywrightPageElement.js.map